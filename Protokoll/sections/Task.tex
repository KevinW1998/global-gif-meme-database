%!TEX root=../Mitschrift.tex
\section{Einführung}
Implementiere die folgende Aufgabenstellung in einer Programmiersprache deiner Wahl!

\subsection{Funktionalität (20 P.)}

Verwende das Decorator Pattern, um die Socket-Kommunikation zwischen einem einfachen Server und einem simplen Client (Konsole genügt) zu dekorieren! Die Plaintext-Kommunikation kann z.B. mit einer RSA- oder AES-Verschlüsselung, einer BASE64-Codierung, einem Hashwert / Fingerprint dekoriert werden.

Zeige im Code, dass die unterschiedlichen Dekorierer miteinander kombiniert werden können!

\subsection{Dokumentation (20 P.)}

Dokumentiere den Code ausführlich (Sphinx / JavaDoc ist nicht erforderlich).

\subsection{Protokoll (30 P.)}
Schreibe ein sauberes (Kopf- und Fußzeile, ...) Protokoll, welches Folgendes beinhaltet:
\begin{itemize}
	\item UML-Klassendiagramm der verwendeten Architektur inkl. Beschreibung
	\item Kurze allgemeine Ausarbeitung zu Design Patterns
		\subitem Wie können Design Patterns unterteilt werden
		\subitem Wozu Design Patterns
		\subitem Übersicht existierender Design Patterns
	\item Ausarbeitung zum Decorator Pattern
		\subitem Allgemeines Klassendiagramm
		\subitem Grundzüge des Design Patterns (wichtige Operationen etc.) am Beispiel des implementierten Programms inkl. spezielles Klassendiagramm
		\subitem Vor- und Nachteile
		\subitem (Weitere) Anwendungsfälle
	\item Ausarbeitung zu einem der folgenden Design Patterns: Observer, Abstract Factory, Strategy
		\subitem Allgemeines Klassendiagramm
	  	\subitem Grundzüge des Design Patterns (wichtige Operationen etc.) mit einem kurzen eigenen Beispiel inkl. spezielles Klassendiagramm
		\subitem Vor- und Nachteile
		\subitem (Weitere) Anwendungsfälle
\end{itemize}
\subsection{Erweiterung (30 P.)}

Implementiere eine zweite Verschlüsselungsart und zeige im Code, wie sie miteinander kombiniert werden können, um Nachrichten zu ver- und entschlüsseln!
